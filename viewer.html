!DOCTYPE html>
<html lang="en">

<head>
  <title>three.js webgl - PLY</title>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
  <link href="https://unpkg.com/tailwindcss@^2/dist/tailwind.min.css" rel="stylesheet">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.6.0/jszip.min.js"
    integrity="sha512-uVSVjE7zYsGz4ag0HEzfugJ78oHCI1KhdkivjQro8ABL/PRiEO4ROwvrolYAcZnky0Fl/baWKYilQfWvESliRA=="
    crossorigin="anonymous" referrerpolicy="no-referrer">
    </script>
  <script src="https://code.jquery.com/jquery-3.6.0.min.js"
    integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous">
    </script>
</head>

<body>
  <style>
    body {
      width: 100vw;
      height: 100vh;
      padding: 0;
      margin: 0;
      overflow: hidden;
    }

    .button {
      background-color: #dddddd;
      border: 1px solid #555555;
      color: black;
      padding: 2px 16px;
      text-align: center;
      text-decoration: none;
      display: inline-block;
      font-size: 16px;
      box-shadow: 0 8px 16px 0 rgba(0, 0, 0, 0.1), 0 6px 20px 0 rgba(0, 0, 0, 0.19);
    }

    .button:active {
      background-color: #eeeeee;
    }

    #root {
      position: relative;
    }

    #canvas,
    #root {
      width: 100%;
      height: 100%;
    }

    #controls {
      position: absolute;
      bottom: 50px;
    }

    #options_container {
      position: absolute;
      top: 1%;
      left: 60%;
      width: 100%;
      float: left;
    }

    .options {
      width: 39%;
      margin-right: 10%;
    }
  </style>


  <div id="root">
    <div id="canvas"></div>

    <div id="options_container" class="d-flex justify-content-between">
      <div class="options bg-white rounded-md p-2">
        <div id="cross-sections-list"></div>
        <div id="cross-sections-select"></div>
      </div>
    </div>
  </div>

  <div id="controls" class="w-full p-6">

    <div class="bg-white rounded-md p-6">
      <div class="mb-2">
        <input id="selector" class="w-full" type="range" min="1" max="1" value="1" class="slider" />
      </div>
      <div class="flex">
        <label for="fileModel3D">3D Models: &nbsp;</label>
        <input id="fileModel3D" class="" type="file" />
      </div>
      <div class="flex">
        <button id="showCrossSections" class="button" type="button">Show Cross Sections</button>
        <div id="progress-bar" class="w-full" hidden>
          <div class="flex mb-2 items-center justify-between">
            <div id="progress-creating">
              <span
                class="text-xs font-semibold inline-block py-1 px-2 uppercase rounded-full text-teal-600 bg-teal-200">
                Models were loaded sucessfully!
              </span>
            </div>
            <div class="text-right">
              <span id="progress-percentage" class="text-xs font-semibold inline-block text-teal-600">100%</span>
            </div>
          </div>
          <div class="overflow-hidden h-2 mb-4 text-xs flex rounded bg-teal-200">
            <div id="progress-bar" style="width:100%;"
              class="shadow-none flex flex-col text-center whitespace-nowrap text-white justify-center bg-blue-500">
            </div>
          </div>
        </div>
      </div>
      <button id="change-color" class="button" type="button">Change Color</button>
    </div>
  </div>
  </div>


  <script type="module">

    import * as THREE from 'https://threejsfundamentals.org/threejs/resources/threejs/r119/build/three.module.js';

    import Stats from 'https://threejsfundamentals.org/threejs/resources/threejs/r115/examples/jsm/libs/stats.module.js';

    import { PLYLoader } from 'https://threejsfundamentals.org/threejs/resources/threejs/r115/examples/jsm/loaders/PLYLoader.js';
    import { OrbitControls } from 'https://threejsfundamentals.org/threejs/resources/threejs/r115/examples/jsm/controls/OrbitControls.js';

    let container, stats;

    let camera, cameraTarget, controls, scene, renderer, meshes;

    let crossSections, numCrossSections, numEvents;

    let meshCrossSectionPlane;
    let crossSectionMaterials = [];
    let crossSectionMaterial;
    let config = '';

    // CONSTANTS
    const MATERIAL_GREYSCALE = new THREE.MeshStandardMaterial({ color: 0x8A8173, flatShading: true });
    const MATERIAL_COLORED = new THREE.MeshPhongMaterial({ vertexColors: THREE.VertexColors, side: THREE.DoubleSide });

    let sliderIndex = 0;

    // GLOBALS
    let material = MATERIAL_GREYSCALE;

    fetch('./config.json')
      .then((response) => response.json())
      .then((json) => { init(json.cross_sections); animate(); });

    function init(json_cross_sections) {
      //location.reload();

      crossSections = json_cross_sections;

      container = document.getElementById('canvas');

      camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 10, 15000);
      camera.position.set(1000, 500, 1000);
      camera.lookAt(0, 0, 0);

      cameraTarget = new THREE.Vector3(0, 0, 0);

      scene = new THREE.Scene();

      // LOAD THE CONFIG JSON TO GET THE CROSS-SECTIONS
      // cross sections inside the following list: console.log(cross_sections);

      // LOAD THE CROSS-SECTION TEXTURES (WITHOUR TEXTURES FOR NOW)
      const loader = new THREE.TextureLoader();

      for (let i = 1; i <= crossSections.length; i++) {
        // REMOVED THE TEXTURES FOR NOW
        //let crossSectionTexture = loader.load((i).toString() + '.png');
        //crossSectionTexture.wrapS = crossSectionTexture.wrapT;
        //crossSectionTexture.anisotropy = 16;
        //crossSectionTexture.encoding = THREE.sRGBAEncoding;
        crossSectionMaterial = new THREE.MeshStandardMaterial({ side: THREE.DoubleSide, transparent: true, opacity: 0.5 });
        //crossSectionMaterial = new THREE.MeshStandardMaterial({ map: crossSectionTexture, side: THREE.DoubleSide, transparent:true, alphaTest:0.9 });
        crossSectionMaterials.push(crossSectionMaterial);
      }
      //scene.add(crossSectionMaterial);
      // -----        

      // Lights 
      const ambientLight = new THREE.AmbientLight(0x888888);
      //const hemisphereLight = new THREE.HemisphereLight(0xFFFFFF, 0xFFFFFF, 0.5);
      //const directionalLight = new THREE.DirectionalLight( 0xffffff, 0.8 );
      const pointLight = new THREE.PointLight(0xffffff, 1, 0);
      const pointLight2 = new THREE.PointLight(0xffffff, 1, 0);
      pointLight.position.set(50, 40, 100);
      pointLight2.position.set(-50, 40, 100);
      scene.add(ambientLight);
      scene.add(pointLight);
      scene.add(pointLight2);

      // Renderer
      renderer = new THREE.WebGLRenderer({});
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.setSize(window.innerWidth, window.innerHeight);


      controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true; // an animation loop is required when either damping or auto-rotation are enabled
      controls.dampingFactor = 0.05;

      controls.screenSpacePanning = false;

      controls.minDistance = 100;
      controls.maxDistance = 100000;

      controls.maxPolarAngle = Math.PI / 2;

      container.appendChild(renderer.domElement);

      // stats
      stats = new Stats();
      container.appendChild(stats.dom);

      // resize
      const gridHelper = new THREE.GridHelper(1000, 100);
      const axesHelper = new THREE.AxesHelper(100);

      //scene.add( axesHelper );
      scene.add(gridHelper);
      window.addEventListener('resize', onWindowResize);

      var worldAxis = new THREE.AxesHelper(1000);
      worldAxis.translateY(1);
      scene.add(worldAxis);

    }

    function onWindowResize() {

      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();

      renderer.setSize(window.innerWidth, window.innerHeight);

    }

    function loadCrossSections() {

    }

    function animate() {

      requestAnimationFrame(animate);

      controls.update();
      render();
      stats.update();

    }

    function render() {

      const timer = Date.now() * 0.0005;

      //camera.position.x = Math.sin( timer ) * 2.5;
      //camera.position.z = Math.cos( timer ) * 2.5;

      //camera.lookAt( cameraTarget );     

      renderer.render(scene, camera);
    }



    // barra 'selector', quando há modificação troca no array
    $('#selector').on("change", (evt) => {
      sliderIndex = Number(evt.originalEvent.target.value) - 1;
      meshes.forEach(mesh => scene.remove(mesh));
      meshes[sliderIndex].material = material
      scene.add(meshes[sliderIndex]);
    });

    function lerArquivoZip(url) {
      return new Promise((resolve, reject) => {
        // Carrega o arquivo zip
        $.ajax({
          url: url,
          method: "GET",
          responseType: "blob",
        }).done(function (blob) {
          // Lê o conteúdo do arquivo zip
          JSZip.loadAsync(blob).then(function (zip) {
            // Cria uma lista de promessas para obter as URLs das imagens
            const promises = [];
            zip.forEach(function (relativePath, file) {
              if (!file.dir && /\.(jpg|jpeg|png|gif)$/i.test(file.name)) {
                promises.push(
                  new Promise((resolve, reject) => {
                    file.async("blob").then(function (blob) {
                      const url = URL.createObjectURL(blob);
                      resolve(url);
                    });
                  })
                );
              }
            });

            // Aguarda todas as promessas serem resolvidas
            Promise.all(promises).then((urls) => {
              if (urls.length > 0) {
                resolve(urls);
              } else {
                reject("A lista de URLs de imagens está vazia.");
              }
            });
          }).catch(function (err) {
            reject(err);
          });
        }).fail(function (err) {
          reject(err);
        });
      });
    }

    const getImagesZIP = async (url) => {
      const response = await fetch(url);
      const arrayBuffer = await response.arrayBuffer();
      const zip = await JSZip.loadAsync(arrayBuffer);

      const imagesList = [];

      for (const relPath in zip.files) {
        if (!zip.files.hasOwnProperty(relPath)) continue;

        const file = zip.files[relPath];
        if (file.dir === true || !/\.(jpg|jpeg|png|gif)$/i.test(relPath)) continue;

        const blob = await file.async("blob");
        const imageURL = URL.createObjectURL(blob);

        imagesList.push(imageURL);
      }

      return imagesList;
    };

    async function obterUrlsImagens(url) {
      const select = document.createElement("select"); // cria o elemento select

      const imagesList = await getImagesZIP(url);

      //Mostrar a imagem na tela
      var div = document.getElementById('cross-sections-list');
      var currentCrossSectionImg = imagesList[0];

      div.innerHTML = 'Current cross-section: <img src= ' + currentCrossSectionImg + ' alt="cross sec" width="1000" height="1000">';

      // cria uma opção para cada imagem
      for (let i = 0; i < imagesList.length; i++) {
        const option = document.createElement("option"); // cria o elemento option
        option.text = "Imagem " + i; // define o texto da opção
        option.value = imagesList[i]; // define o valor da opção como a URL da imagem
        select.add(option); // adiciona a opção na lista de opções do select
      }

      select.addEventListener("change", function (event) {
        // obtém o valor selecionado
        const selectedValue = event.target.value;

        // faz algo com o valor selecionado, como exibir a imagem
        var div = document.getElementById('cross-sections-list');
        var currentCrossSectionImg = selectedValue;

        div.innerHTML = 'Current cross-section: <img src= ' + currentCrossSectionImg + ' alt="cross sec" width="1000" height="1000">';
      });

      const container = document.getElementById("cross-sections-select"); // seleciona a tag com id "container"
      container.innerHTML = ''; // removendo os selects adicionados anteriormente
      container.appendChild(select); // adiciona o select na tag selecionada
    }

    $('#showCrossSections').click(function () {
      if (sliderIndex != 0) {
        var url = "./cross_sections_PNG-SavingPoint" + sliderIndex + ".zip";
        obterUrlsImagens(url); // Chama a função para obter as URLs de imagens
      }
    });

    // put all the cross-sections into a matrix
    $('#change-color').click(function () {
      if (material == MATERIAL_COLORED)
        material = MATERIAL_GREYSCALE;
      else
        material = MATERIAL_COLORED;

      meshes.forEach(mesh => scene.remove(mesh));
      meshes[sliderIndex].material = material
      scene.add(meshes[sliderIndex]);
    })

    $("#fileModel3D").on("change", function (evt) {
      if (!evt.target.files || evt.target.files.length === 0) {
        return;
      }

      $("#progress-bar").removeAttr("hidden");
      //console.log('Starting 3D Models');
      const fileModel3D = evt.target.files[0];
      JSZip.loadAsync(fileModel3D)                                         // 1) read the Blob
        .then(function (zip) {
          meshes = Object.keys(zip.files).map(_ => null);
          //meshes_greyscale = Object.keys(zip.files).map(_ => null);
          const N = meshes.length; // -1 = folder!

          $('#selector').attr('max', N);

          let firstPass = true;

          zip.forEach(function (relativePath, zipEntry) {  // 2) print entries
            const name = zipEntry.name.split('/').reverse()[0];
            const index = Number(name.split('.')[0]) - 1;
            //console.log(relativePath, zipEntry);
            var reader = new FileReader();
            reader.onload = function () {
              THREE.CullFaceNone;
              var loader = new PLYLoader();
              var geometry = loader.parse(this.result);
              geometry.computeBoundingSphere();
              geometry.computeVertexNormals();
              var scale = 50 / geometry.boundingSphere.radius;
              var mesh = new THREE.Mesh(geometry, MATERIAL_COLORED);
              mesh.scale.set(scale * 5, scale * 5, scale * 5);
              mesh.translateX(-200);
              mesh.translateY(1);
              mesh.translateZ(30);
              mesh.rotateX(-Math.PI / 2);
              mesh.matrixWorldNeedsUpdate = true;

              if (firstPass) {
                // Axis for debug purposes
                //var worldAxis = new THREE.AxesHelper(2000);
                //scene.add(worldAxis);

                // Creating the planes
                var bbox = new THREE.Box3().setFromObject(mesh);
                var crossSectionWidth = 1.29 * (bbox.max.z - bbox.min.z);

                for (let i = 0; i < crossSections.length; i++) {
                  // used previously for the textures
                  meshCrossSectionPlane = new THREE.Mesh(new THREE.PlaneBufferGeometry(crossSectionWidth, bbox.max.y - bbox.min.y - 1), crossSectionMaterials[i]);
                  meshCrossSectionPlane.position.x = -200.0;
                  meshCrossSectionPlane.position.y = -12.0;
                  meshCrossSectionPlane.position.z = 0.0;
                  meshCrossSectionPlane.translateY(40);
                  meshCrossSectionPlane.translateZ(1 * (0.0125 * crossSectionWidth));
                  meshCrossSectionPlane.translateX(crossSections[i] * (bbox.max.x - bbox.min.x)); // where along the channel length                  
                  meshCrossSectionPlane.rotation.y = -Math.PI / 2;
                  meshCrossSectionPlane.overdraw = true;
                  scene.add(meshCrossSectionPlane);
                }

                firstPass = false;
              }

              //scene.add(mesh);              
              meshes[index] = mesh;

              meshes.forEach(mesh => scene.remove(mesh));
              meshes[sliderIndex].material = material
              scene.add(meshes[sliderIndex]);

            };
            zipEntry.async("blob").then(function (content) { reader.readAsArrayBuffer(content); });
          });


        }, function (e) {
          $result.append($("<div>", {
            "class": "alert alert-danger",
            text: "Error reading " + f.name + ": " + e.message
          }));
        });
    });
  </script>
</body>

</html>