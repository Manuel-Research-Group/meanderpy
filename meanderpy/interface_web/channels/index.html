<!DOCTYPE html>
<html lang="en">
<meta charset="utf-8">
<style>
  body {
    font: 14px arial;
    position: relative;
    width: 960px;
    height: 500px;
  }

  svg {
    font: 16px arial;
  }

  rect {
      fill: none;
      pointer-events: all;
  }

  circle,
  .spline,
  .spline-elevation {
    fill: none;
    stroke: rgb(143, 56, 30);
    stroke-width: 2.5px;
  }

  circle {
    fill: #fff;
    fill-opacity: .2;
    cursor: move;
  }

  .selected {
    fill: #eb0eff;
    stroke: #eb0eff;
  }

  .axis {
    shape-rendering: crispEdges;
  }

  .x.axis line {
    stroke: rgb(150, 150, 150);
  }

  .x.axis .minor {
    stroke-opacity: .5;
  }

  .x.axis path {
    display: none;
  }

  .y.axis line,
  .y.axis path {
    fill: none;
    stroke: #000;
  }

  .formulario {
    position: absolute;
    margin-top: 20px;
    left: 950px;
  }

  .topnav {
      overflow: hidden;
      background-color: #333;
  }

  .topnav a {
      float: left;
      color: #f2f2f2;
      text-align: center;
      padding: 14px 16px;
      text-decoration: none;
      font-size: 17px;
  }

  .topnav a:hover {
      background-color: #ddd;
      color: black;
  }

  .topnav a.active {
      background-color: #04AA6D;
      color: white;
  }

</style>
<head>
  <title>Turbidite Channel Customization - Profile</title>
</head> 
<body>
  <div class="topnav">
    <a href="https://www.inf.ufrgs.br/~dgbalreira/turbidite/">Home</a>
    <a class="active" href="https://www.inf.ufrgs.br/~dgbalreira/tubidite/channels">Channel Profile</a>
    <a href="https://www.inf.ufrgs.br/~dgbalreira/turbidite/config">Channel Configuration</a>
    <a href="https://www.inf.ufrgs.br/~dgbalreira/turbidite/events">Channel Events</a>
</div>
  <h1>Channel Profile</h1>  
  <div class = "formulario">    
    <label for="width">Width (m):</label>
    <input id="width" value="500"></input><br><br>

    <label for="length">Length (m):</label>
    <input id="length" value="10000"></input><br><br>

    <label for="elevation">Elevation (m):</label>
    <input id="elevation" value="500"></input><br><br>

    <button onclick="download(); return false;">Save Control Points</button> <br> <br>

    <!--<a href="https://www.inf.ufrgs.br/~dgbalreira/turbidite/channels/channelProfile.zip">Download Python Version (400MB)</a>-->
  </div>
</body>
<script src="https://d3js.org/d3.v3.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.21/lodash.min.js"></script>
<script>
var margin = {top: 40, right: 40, bottom: 50, left: 70},
    width = 960 - margin.left - margin.right,
    height = 500 - margin.top - margin.bottom;

const SINUOSITY = 0;
const SLOPE = 1;

var radius = 6.5;

var x = d3.scale.linear()
    .range([0, width]);

var y = d3.scale.linear()
    .range([height, 0]);

var yElevation = d3.scale.linear()
    .range([height, 0]);

var xAxis = d3.svg.axis()
    .scale(x)
    .tickSize(-height);

var yAxis = d3.svg.axis()
    .scale(y)
    .orient("left")
    .tickSize(-width);

var yAxisElevation = d3.svg.axis()
    .scale(yElevation)
    .orient("left")
    .tickSize(-width);

var points = [[0, height/2], [width/3, height/2], [width/1.5, height/2], [width, height/2]];
var pointsElevation =  [[0, 0], [width/3, height/3], [2*width/3, 2*height/3], [width, height]];

var dragged = null,
    draggedElevation = null,
    selected = points[0],
    selectedElevation = pointsElevation[0];

var line = d3.svg.line()
    .interpolate("basis");

var lineElevation = d3.svg.line()
    .interpolate("basis");

var svg = d3.select("body").append("svg")
    .attr("width", width + margin.left + margin.right)
    .attr("height", height + margin.top + margin.bottom)
  .append("g")
    .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

svg.append("rect")
    .attr("width", width)
    .attr("height", height)
    .on("mousedown", mousedown);

svg.append('line')
    .style("stroke", "black")
    .style("stroke-width", 2)
    .attr("x1", 0)
    .attr("y1", height/2)
    .attr("x2", width)
    .attr("y2", height/2);

x.domain([0, 10000]);
y.domain([-500, 500]);
yElevation.domain([0,500]);

svg.append("text")
    .attr("x", (width/2))
    .attr("y", 0 - (margin.top / 2))
    .attr("text-anchor", "middle")
    .attr("font-weight", 600) // [bold] value between 100 and 900
    .style("font-size", "16px")     
    .text("Channel Top View");

svg.append("g")
    .attr("class", "x axis")
    .attr("transform", "translate(0," + height + ")")
    .call(xAxis)
.append("text")
    .classed("label", true)
    .attr("x", width/2+20)
    .attr("y", margin.bottom - 10)
    .style("text-anchor", "end")
    .text("Length (m)");

svg.append("g")
    .attr("class", "y axis")
    .call(yAxis)
.append("text")
    .classed("label", true)
    .attr("transform", "rotate(-90)")
    .attr("x", -height/2 + 20)
    .attr("y", -margin.left+5)
    .attr("dy", ".71em")
    .style("text-anchor", "end")
    .text("Width (m)");

svg.append("path")
    .datum(points)
    .attr("class", "spline")
    .call(redraw);

d3.select(window)
    .on("mousemove", function(){  mousemove(); mousemoveElevation();})
    .on("mouseup", function(){  mouseup(); mouseupElevation();})
    .on("keydown", function(){  keydown(); keydownElevation();})

  
// Adicionar o novo svg para Elevation
var svgElevation = d3.select("body").append("svg")
    .attr("width", width + margin.left + margin.right)
    .attr("height", height + margin.top + margin.bottom)
  .append("g")
    .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

svgElevation.append("text")
    .attr("x", (width/2))
    .attr("y", 0 - (margin.top / 2))
    .attr("text-anchor", "middle")
    .attr("font-weight", 600)
    .style("font-size", "16px")     
    .text("Channel Side View");

svgElevation.append("rect")
    .attr("width", width)
    .attr("height", height)
    .on("mousedown", mousedownElevation)
  .append("text")
      .classed("label", true)
      .attr("x", width/3)
      .attr("y", margin.bottom - 10)
      .style("text-anchor", "end")   
      
svgElevation.append('line')
    .style("stroke", "black")
    .style("stroke-width", 2)
    .attr("x1", 0)
    .attr("y1", height/2)
    .attr("x2", width)
    .attr("y2", height/2);

svgElevation.append("g")
      .attr("class", "x axis")
      .attr("transform", "translate(0," + height + ")")
      .call(xAxis)
  .append("text")
      .classed("label", true)
      .attr("x", width/2+20)
      .attr("y", margin.bottom - 10)
      .style("text-anchor", "end")
      .text("Length (m)");

svgElevation.append("g")
    .attr("class", "y axis elevation")
    .call(yAxisElevation)
  .append("text")
    .classed("label", true)
    .attr("transform", "rotate(-90)")
    .attr("x", -height/2 + 30)
    .attr("y", -margin.left+5)
    .attr("dy", ".71em")
    .style("text-anchor", "end")
    .text("Elevation (m)"); 

svgElevation.append("path")
    .datum(pointsElevation)
    .attr("class", "spline-elevation")
    .call(redrawElevations);

function redraw() {
   svg.select(".spline").attr("d", line);

  var circle = svg.selectAll("circle")
      .data(points, function(d, i) { d.index = i; return d; });

  circle.enter().append("circle")
      .attr("r", 1e-6)
      .on("mousedown", function(d) { selected = dragged = d; redraw(); })
    .transition()
      .duration(750)
      .ease("elastic")
      .attr("r", radius);

  circle
      .classed("selected", function(d) { return d === selected; })
      .attr("cx", function(d) { return d[0]; })
      .attr("cy", function(d) { return d[1]; });

  circle.exit().remove();

  if (d3.event) {
    d3.event.preventDefault();
    d3.event.stopPropagation();
  }
}

function redrawElevations() {
  svgElevation.select(".spline-elevation").attr("d", lineElevation);

  var circle = svgElevation.selectAll("circle")
      .data(pointsElevation, function(d, i) { d.index = i; return d; });

  circle.enter().append("circle")
      .attr("r", 1e-6)
      .on("mousedown", function(d) { selectedElevation = draggedElevation = d; redrawElevations(); })
    .transition()
      .duration(750)
      .ease("elastic")
      .attr("r", radius);

  circle
      .classed("selected", function(d) { return d === selectedElevation; })
      .attr("cx", function(d) { return d[0]; })
      .attr("cy", function(d) { return d[1]; });

  circle.exit().remove();

  if (d3.event) {
    d3.event.preventDefault();
    d3.event.stopPropagation();
  }
}

function mousedown() {
  points.push(selected = dragged = d3.mouse(svg.node()));
  points.sort(function(a, b){
    return a[0] - b[0];
    });
  redraw();
}

function mousemove() {
    if (!dragged) return;
    var m = d3.mouse(svg.node());
    console.log(m);
    var currentIndex = dragged.index;
    if (currentIndex !== 0 && currentIndex !== points.length - 1) {
        dragged[0] = Math.max(points[currentIndex-1][0] + (2 * radius), Math.min(points[currentIndex+1][0] - (2 * radius), m[0]));
        dragged[1] = Math.max(0, Math.min(height, m[1]));
    }
    else
        dragged[1] = Math.max(0, Math.min(height, m[1]));

  redraw();
}

function mouseup() {
  if (!dragged) return;
  mousemove();
  dragged = null;
}

function keydown() {
  if (!selected) return;
  switch (d3.event.keyCode) {
    case 46: { // delete
      var i = points.indexOf(selected);
      if (i === 0 || i === points.length - 1)
        break;
      points.splice(i, 1);
      selected = points.length ? points[i > 0 ? i - 1 : 0] : null;
      redraw();
      break;
    }
  }
}


// Replicar funções
function mousedownElevation() {
  var m = d3.mouse(svg.node());
  m[1] = m[1] - 500;
  pointsElevation.push(selectedElevation = draggedElevation = m);
  pointsElevation.sort(function(a, b){
    return a[0] - b[0];
    });
  redrawElevations();
}

function mousemoveElevation() {
    if (!draggedElevation) return;
    var m = d3.mouse(svg.node());
    m[1] = m[1] - 500;
    var currentIndex = draggedElevation.index;
    if (currentIndex !== 0 && currentIndex !== pointsElevation.length - 1) {
        draggedElevation[0] = Math.max(pointsElevation[currentIndex-1][0] + (2 * radius), Math.min(pointsElevation[currentIndex+1][0] - (2 * radius), m[0]));
        draggedElevation[1] = Math.max(0, Math.min(height, m[1]));
    }
    else
      draggedElevation[1] = Math.max(0, Math.min(height, m[1]));

  redrawElevations();
}

function mouseupElevation() {
  if (!draggedElevation) return;
  mousemoveElevation();
  draggedElevation = null;
}

function keydownElevation() {
  if (!selectedElevation) return;
  switch (d3.event.keyCode) {
    case 46: { // delete
      var i = pointsElevation.indexOf(selectedElevation);
      if (i === 0 || i === pointsElevation.length - 1)
        break;
      pointsElevation.splice(i, 1);
      selectedElevation = pointsElevation.length ? pointsElevation[i > 0 ? i - 1 : 0] : null;
      redrawElevations();
      break;
    }
  }
}


var widthInput = document.getElementById("width");
widthInput.addEventListener("keyup", function(event) {
  if (event.keyCode === 13) {
   event.preventDefault(); 
   y.domain([-widthInput.value, widthInput.value]);
   d3.select("g.y.axis")
    .call(yAxis)
  }
});


var lengthInput = document.getElementById("length");
lengthInput.addEventListener("keyup", function(event) {
  if (event.keyCode === 13) {
   event.preventDefault(); 
   x.domain([0, lengthInput.value]);
   d3.selectAll("g.x.axis")
    .call(xAxis)
  }
});

var elevationInput = document.getElementById("elevation");
elevationInput.addEventListener("keyup", function(event) {
  if (event.keyCode === 13) {
   event.preventDefault(); 
   yElevation.domain([0, elevationInput.value]);
   d3.select("g.y.axis.elevation")
      .call(yAxisElevation)
  }
});

//function download(content, fileName, contentType) {
function download() {
  minNew = [0, -widthInput.value];
  maxNew = [lengthInput.value, widthInput.value];

  // bounding box of the canvas
  minCur = [0,0];
  maxCur = [width, height];

  var savePoints = pointTransformCoordinates(points, minCur, maxCur, minNew, maxNew, SINUOSITY);

  minNew = [0, 0];
  maxNew = [lengthInput.value, elevationInput.value];
  var savePointsElevation = pointTransformCoordinates(pointsElevation, minCur, maxCur, minNew, maxNew, SLOPE);

  var fileName = "channels.json", contentType="application/json";
  var content = {width: Number(widthInput.value), length: Number(lengthInput.value), elevation: Number(elevationInput.value)};
  var sinuosity = [];
  var slope = [];
  
  for (i = 0; i < savePoints.length; i++) {
    sinuosity.push(savePoints[i])
  }
  content.sinuosity = sinuosity;

  for (i = 0; i < savePointsElevation.length; i++) {
    slope.push(savePointsElevation[i])
  }
  content.slope = slope;

  var a = document.createElement("a");
  var file = new Blob([JSON.stringify(content, null, 2)], {type: contentType});
  a.href = URL.createObjectURL(file);
  a.download = fileName;
  a.click();
}

// Function receives points[n][2], minCur[2], maxCur[2], minNew[2], maxNew[2] and transform the points to the new coordinate system
// Min-Max Normalization (Final values are in between 0 and 1):
// v_ = (v - min(A)) / (max(A) - min(A))
function pointTransformCoordinates(points, minCur, maxCur, minNew, maxNew, mode) {
  let newPoints = _.cloneDeep(points);  

  for (i = 0; i < newPoints.length; i++) {
    newPoints[i][0] = (newPoints[i][0] - minCur[0]) / (maxCur[0]-minCur[0]); // x axis normalization
    newPoints[i][1] = (newPoints[i][1] - minCur[1]) / (maxCur[1]-minCur[1]); // y axis normalization
    
    newPoints[i][0] = (newPoints[i][0]) * (maxNew[0] - minNew[0]);

    if (mode == SINUOSITY)
      newPoints[i][1] = -1*((newPoints[i][1]) * (maxNew[1] - minNew[1]) + minNew[1]);
    else
      newPoints[i][1] = (maxNew[1] - ((newPoints[i][1]) * (maxNew[1] - minNew[1])));
  }

  return newPoints;  
}

function printArray(arr) {
  for (i = 0; i < arr.length; i++) {
    console.log(arr[i]);
  }
}
</script>

</html>